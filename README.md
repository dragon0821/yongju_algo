_<h1 align="center">이것이 코딩테스트이다_나동빈</h1>_
[![Build Status](https://travis-ci.org/joemccann/dillinger.svg?branch=master)](https://travis-ci.org/joemccann/dillinger)

_**Better Problem Solving**<br><br>
책에 나와 있는 모든 정렬 문제를 해결함
<br><br>
선택정렬<br>
가장 작은 것을 선택하는 방법으로, 데이터가 무작위로 여러개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복하는 정렬 방법이다. <br><br>
선택정렬의 시간 복잡도<br>
선택정렬은 N-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다. 또한 매번 가장 작은 수를 찾기 위해서 비교 연산이 필요하다. 그러므로 선택정렬의 시간 복잡도는 O(N^2)이다. 2중 반복문을 사용하기 떄문이다.<br><br><br>
삽입정렬<br>
삽입정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다. 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 특징이 있다.<br>
특정한 데이터의 왼쪽에 있는 데이터들은 이미 정렬이 된 상태이므로 자기보다 작은 데이터를 만났다면 더 이상 데이터를 살펴볼 필요 없이 그 자리에 삽입되는 된다.<br>
-> 첫번째 데이터는 그 자체로 정렬되어 있다는 가정이 있음. <br>
-> 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다.<br><br>
삽입정렬은 특히 데이터가 거의 정렬되어 있을 때 훨씬 효율적임.<br><br>
삽입정렬의 시간복잡도<br>
시간 복잡도는 O(N^2)이다. 하지만, 삽입정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다. 퀵 정렬과 비교했을 때 보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어 있는 상황에서는 퀵 정렬 알고리즘 보다 강력하다.<br><br><br>
퀵 정렬<br>
퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.<br>
피벗을 설정한 뒤, 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교화해준다. 이러한 과정을 반복하면 피벗에 대하여 정렬이 수행된다.<br><br>
퀵 정렬의 시간 복잡도<br>
퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다. 하지만 최악의 경우에는 O(N^2)이다. 무작위로 입력되는 경우 퀵 정렬은 빠르게 동작할 확률이 높다. 하지만 이미 데이터가 정렬되어 있는 경우에는 매우 느리게 동작한다.<br><br>
실제로 c++와 같이 퀵 정렬을 기반으로 작성된 정렬 라이브러리를 제공하는 프로그래밍 언어들은 최악의 경우에도 O(NlogN)이 되는 것을 보장할 수 있도록 피벗값을 설정할때 추가적인 로직을 더해준다. 고로 정렬 라이브러리의 사용은 시간복잡도가 O(NlogN)이다.<br><br><br>
계수 정렬<br>
계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때만 사용할 수 있다. 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.<br>
->모든 범위를 담을 수 있는 크기의 리스트를 선언해야 하기 때문이다. <br>
계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.<br>
먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다. 처음에는 리스트의 모든 데이터가 0이 되도록 초기화한다. 그 다음 데이터를 하나씩 확인하여 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면 계수정렬이 완료된다.<br><br>
계수 정렬의 시간복잡도와 공간 복잡도<br>
계수 정렬의 시간복잡도는 O(N+K)이다. *N은 데이터의 개수, K는 데이터 중 최대값의 크기<br>
계수정렬의 공간복잡도는 O(N+K)이다. 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다. 예를들어, 데이터가 0과 999,999. 단 2개만 존재하는 경우 이런 상황에도 리스트의 크기가 100만개가 되도록 선언해야한다. 따라서 항상 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.<br>
즉, 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수는 없다.<br><br><br>

정렬 문제의 유형 정리<br>
1번 정렬 라이브러리로 풀 수 있는 문제 : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.<br>
2번 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.<br>
3번 더 빠른 정렬이 필요한 문제 : 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수있다.
<br><br><br><br><br>
## Assignments
- [국영수](https://www.acmicpc.net/problem/10825)
- [안테나](https://www.acmicpc.net/problem/18310)
- [실패율](https://programmers.co.kr/learn/courses/30/lessons/42889)
- [카드 정렬하기](https://www.acmicpc.net/problem/1715)